@startmindmap
+ JVM
++ JVM调优
+++ 常见参数
++++ Xms
+++++ 堆内存初始大小
++++ Xmx
+++++ 堆内存最大值（一般设置 +Xms=+Xmx。这样可以获得固定大小的堆内存，减少GC 次数和耗时，可以使得堆相对稳定）
++++ Xmn
+++++ 设置新生代的大小。太小会增加YGC，太大会减小老年代大小，一般设置为整个堆的1/4到1/3；
++++ Xss
+++++ 设置Java 线程堆栈大小
++++ +XX:SurvivorRatio
+++++ 年轻代和两个Survivor的比值。默认值为8，代表比值为 8:1:1；
++++ +XX:NewRatio
+++++ 设置年轻代和年老代的比值。如果为3，表示年轻代与老 年代比值为 1:3，默认值为2；
++++ +XX:+PrintGCDetails
+++++ 开启GC日志
++++ +XX:ParallelGCThreads
+++++ 设置 STW 工作线程数的值。将n的值设置为逻辑处理器的数量。n的值与逻辑处理器的数量相同，最多为 8。
++++ +XX:+HeapDumpOnOutOfMemoryError
+++++ 让 JVM 在发生内存溢出的时候自动生成内存快照，方便排查问题
++++ +XX:+UseG1GC
+++++ 使用G1垃圾收集器
++++ +XX:MaxGCPauseMillis
+++++ 设置最大的垃圾收集时的停顿时间，单位为毫秒
+++ 健康GC指标
++++ minor GC 单次耗时 < 50ms，频率10秒以上。说明年轻代OK。
++++ Full GC 单次耗时 < 1秒，频率10分钟以上（最好没有），说明年老代OK。
++++ CMS GC  一天一次左右
+++ GC调优目的
++++ GC时间够少，GC次数够少
+++ 调优思路
++++ 优化维度
+++++ 频率
++++++ YGC
+++++++ 如果 YGC 超过5秒一次，甚至更长，说明系统内存 过大，应该缩小容量，\l如果频率很高，说明 Eden 区过小，可以将 Eden 区增 大，\l但整个新生代的容量应该在堆的 30% ­ 40%之间，eden，from 和 to 的比 例应该在 8：1：1左右，\l这个比例可根据对象晋升的大小进行调整。
++++++ FGC 
+++++++ 1 Old 区内存不够
++++++++ FGC 后还有大量对象
+++++++++ 说明 Old 区过小，应该扩大 Old 区
++++++++ FGC 后效果很好
+++++++++ 说明 Old 区存在了大量 短命的对象，\l优化的点应该是让这些对象在新生代就被 YGC 掉
++++++++++ 通常的做法是 增大新生代，如果有大而短命的对象，通过参数设置对象的大小，\l不要让这些对 象进入 Old 区，还需要检查晋升年龄是否过小。
++++++++++ 如果 YGC 后，有大量对象因为 无法进入 Survivor 区从而提前晋升，\l这时应该增大 Survivor 区，但不宜太大
+++++++ 2 元数据区内存不够
+++++++ 3 System.gc()
+++++++ 4 jmap 或者 jcmd，
+++++++ 5 CMS Promotion failed 或者 concurrent mode failure
+++++++ 6 JVM 基于悲观策略认为这次 YGC 后 Old 区无法容纳晋升的对象，因此取消 YGC，提前 FGC
+++++ 时长
++++++ YGC
+++++++ YGC 有2个过程，一个是扫描，一个是复制，通常扫描 速度很快，复制速度相比而言要慢一些。
+++++++ 如果每次都有大量对象要复制，就会将STW 时间延长，还有一个情况就是 StringTable ，\l这个数据结构中存储着 String.intern 方法返回的常量池的引用，
+++++++ YGC 每次都会扫描这个数据结构 （HashTable），如果这个数据结构很大，且没有经过 FGC，那么也会拉长 STW 时长，
+++++++ 还有一种情况就是操作系统的虚拟内存，当 GC 时正巧操作系统正 在交换内存，也会拉长 STW 时长。
++++++ FGC
+++++++ 无法优化时长，无法控制
++++ 确定是否有频繁Full GC现象
+++++ 1 如果Full GC频繁，那么考虑内存泄漏的情况
++++++ 内存泄漏角度
+++++++ 1 使用jps +l命令获取虚拟的LVMID
+++++++ 2 使用jstat +gc lvmid 命令获取虚拟机的执行状态，判断Full GC次数
+++++++ 3 使用jmap +histo:live 分析当前堆中存活对象数量
+++++++ 4 如果还不能定位到关键信息，使用jamp +dump打印当前堆栈映像dump文件
++++++++ jmap +dump:format=b,file=/usr/local/base/02.hprof 129090
+++++++ 5 使用MAT等工具分析dump文件，一般使用的参数是Histogram或者Dominator Tree,\l分析出各个对象的内存占用率，并根据对象引用情况找到泄漏点
+++++ 2 如果Full GC不频繁，各个区域内存占用也很正常，\l那么考虑线程阻塞，死锁，死循环等情况
++++++ 线程角度
+++++++ 1 使用jps +l命令获取虚拟的LVMID
+++++++ 2 使用 jstack 分析各个线程的堆栈内存使用情况,如果说系统慢,\l那么要特别关注Blocked,Waiting on condition,\l如果说系统的cpu耗的高，那么肯定是线程执行有死循环，那么此时要关注下Runable状态。
+++++++ 3 如果还不能定位到关键信息，使用jamp +dump打印当前堆栈映像dump文件
+++++++ 4 使用MAT等工具分析dump文件，一般使用的参数是Histogram或者Dominator Tree,\l分析出各个对象的内存占用率，并根据对象引用情况找到泄漏点
+++++ 3 如果都不是，考虑堆外存溢出，或者是外部命令等情况 
++++++ Runtime.getRuntime.exec()
@endmindmap
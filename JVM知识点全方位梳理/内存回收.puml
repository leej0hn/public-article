@startmindmap
+ JVM
++ 内存回收
+++ 对象是否存在
++++ 引用计数法
*****: 给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。
引用计数为0的对象可被回收;
+++++ 缺陷：循环引用会导致内存泄漏
++++ 可达性分析算法
*****: 该算法是通过一系列的称为“GC Roots”的对象作为起始点,
从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),
当一个对象到GC Roots没有任何引用链相连
(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。;
+++++ GC Roots
++++++ 当前虚拟机栈中局部变量表中的引用的对象
++++++ 当前本地方法栈中局部变量表中的引用的对象
++++++ 方法区中类静态属性引用的对象
++++++ 方法区中的常量引用的对象
++++ 判断一个对象是否可回收的过程(两步)
+++++ 1 找到GC Roots不可达的对象，<B>如果没有重写finalize()或者调用过finalize()</B>,则将该对象加入到F-Queue中
+++++ 2 再次进行标记，如果此时对象还未与GC Roots建立引用关系，则被回收
+++ 回收对象引用类型
++++ 强引用
+++++ 垃圾回收器绝对不会回收它，当内存不足时宁愿抛出OOM错误，使得程序异常停止
++++ 软引用
+++++ 垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收它
+++++ 软引用非常适合创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。
++++ 弱引用
+++++ 垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。
++++++ <B>ThreadLocal的key是弱引用
++++ 虚引用
+++++ 如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。
+++++ 虚引用主要用来跟踪对象被垃圾回收器回收的活动
+++ 垃圾收集算法
++++ 标记-清除
+++++ 过程
++++++ 1. 将需要回收的对象标记起来
++++++ 2. 清除对象
+++++ 缺陷
++++++ 1. 标记和清除的效率都不高
++++++ 2. 产生大量的不连续的内存碎片
++++ 复制算法
*****: 复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，
当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。;
+++++ 新生代使用的是复制算法
+++++ 优点
++++++ 简单高效，不会出现内存碎片问题
+++++ 缺陷
++++++ 内存利用率低
++++++ 存活对象较多时效率明显会降低
++++ 标记-整理
*****: 原理和标记清除算法类似，只是最后一步的清除改为了<B>将存活的对象全部移动到一端，
然后再将边界之外的内存全部回收。;
+++++ 老年代使用的是标记-整理算法
+++++ 缺陷
++++++ 需要移动大量对象，效率不高
++++ 分代回收算法
+++++ 根据各个年代的特点选取不同的垃圾收集算法
+++++ 新生代使用复制算法
+++++ 老年代使用标记-整理或者标记-清除算法
+++ 垃圾收集器
++++ Serial收集器
+++++ 串行单线程收集器
+++++ 优点：简单高效
+++++ 是Client模式下的默认新生代收集器
++++ ParNew收集器
+++++ Serial收集器的多线程版本
*****: 是Server模式下的虚拟机首选新生代收集器，除了性能原因外，
主要是因为<B>除了Serial收集器，只有它能与CMS收集器配合工作。;
++++ Parallel Scavenge收集器
+++++ 多线程收集器
+++++ “吞吐量优先”收集器，更加关注系统的吞吐量
+++++ 适合在后台运算而不需要太多交互的任务
++++ Serial Old收集器
+++++ Serial收集器的老年代版本
+++++ 可用于Client模式下
+++++ 用于Server模式下时
++++++ 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用
++++++ 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
++++ ParNew Old收集器
+++++ Parallel Scavenge收集器的老年代版本
+++++ 注重程序吞吐量
++++ CMS收集器
+++++ 流程
++++++ 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，<B>需要停顿（STW）
++++++ 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。
++++++ 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<B>需要停顿(STW)
++++++ 并发清除：不需要停顿。
+++++ 缺陷
++++++ 吞吐量低
+++++++ 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高
++++++ 无法处理浮动垃圾，可能出现 Concurrent Mode Failure
*******: 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，
这部分垃圾只能到下一次 GC 时才能进行回收;
*******: 由于浮动垃圾的存在，因此需要预留出一部分内存，
意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。;
*******: 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，
<B>这时虚拟机将临时启用 Serial Old 来替代 CMS;
++++++ 会产生空间碎片
+++++++ 标记-清除算法会导致产生不连续的空间碎片
++++ G1收集器
+++++ G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
+++++ 流程
******: 初始标记：仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，
让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。;
******: 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，
此阶段耗时较长，但可与用户程序并发执行。;
******: 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，
虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，
最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。
这阶段需要停顿线程(STW)，但是可并行执行。;
******: 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。
此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，
时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。;
+++++ 特点
++++++ 空间整合，不会产生内存碎片
++++++ 可预测的停顿
+++++ 参数设置
++++++ -XX:+UseG1GC
++++++ -XX:MaxGCPauseMillis
@endmindmap
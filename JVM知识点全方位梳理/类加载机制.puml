@startmindmap
+ JVM
++ 类加载机制
+++ 类生命周期
++++ 加载
++++ 验证
++++ 准备
++++ 解析
++++ 初始化
++++ 使用
++++ 卸载
+++ 类加载器
++++ 启动类加载器
+++++ C++实现，是虚拟机自身的一部分
+++++ 负责将存放在<JRE_HOME>/lib 目录中的类库加载到虚拟机内存中
++++ 其他加载器
+++++ 由Java实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader
+++++ 分类
++++++ 启动类加载器
++++++ 扩展类加载器
*******: 它负责将<JAVA_HOME>/lib/ext或者
被java.ext.dir系统变量所指定路径中的所有类库加载到内存中;
++++++ 应用程序类加载器
+++++++ 它负责加载用户类路径(ClassPath)上所指定的类库
++++++ 自定义类加载器
+++++++ 用户根据需求自己定义的。也要需要继承自己的ClassLoader
++++ 双亲委派模型
+++++ 内容
******:如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，
而是把这个请求委派给父类加载器完成，
只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），
子加载器才会尝试自己去加载。;
+++++ 实现
++++++ 首先检查类是否被加载；
++++++ 若未加载，则调用父类加载器的loadClass方法；
++++++ 若该方法抛出ClassNotFoundException异常，则表示父类加载器无法加载，则当前类加载器调用findClass加载类；
++++++ 若父类加载器可以加载，则直接返回Class对象；
+++++ 好处
++++++ 保证java类库中的类不受用户类影响，防止用户自定义一个类库中的同名类，引起问题
+++++ 破坏
++++++ 基础类需要调用用户的代码
+++++++ 解决方式
++++++++ 线程上下文类加载器
*********: 也就是父类加载器请求子类加载器去完成类加载的动作，
这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，
实际上已经违背了双亲委派模型的一般性原;
+++++++ 实现方法
++++++++ 重写ClassLoader类的loadClass()
+++++++ 示例
++++++++ JDBC
*********: 原生的JDB中的类是放在rt.jar包的，是由启动类加载器进行类加载的，
JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类;
++++++++ JNDI服务需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码
++++++ 重写loadClass方法
+++++++ 双亲委派模型的具体实现就在loadClass()方法中
++++++ 用户对程序的动态性的追求
*******: 例如OSGi(面向Java的动态模型系统)的出现。
在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，
而是进一步发展为网状结构。;
+++++++ 代码热替换、模块热部署
++++++ 典型的打破双亲委派模型的框架和中间件有tomcat与osgi
*****: <B>模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
<B>这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，
<B>而不是通过继承（Inheritance）的关系实现。;
+++ 类加载过程
++++ 加载
+++++ 将编译后的.Class静态文件转换到内存中(方法区)，然后暴露出来让程序员能访问到
++++ 验证
+++++ 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
++++ 准备
+++++ 准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存
++++ 解析
+++++ 将class文件的常量池的符号引用替换为直接引用的过程（是静态链接）
+++++ <B>可能发生在初始化阶段之前，也可能发生在初始化阶段之后，后者是为了支持Java的动态绑定。
++++ 初始化
+++++ 为类的静态变量赋予程序中指定的初始值，还有执行静态代码块中的程序（执行<cinit>()方法）。
+++ 类加载方式
++++ 1、命令行启动应用时候由JVM初始化加载
++++ 2、通过Class.forName()方法动态加载
++++ 3、通过ClassLoader.loadClass()方法动态加载
+++ 类加载时机
++++ 遇到new,getStatic,putStatic,invokeStatic这四条指令
+++++ new一个对象时
+++++ 调用一个类的静态方法
+++++ 直接操作一个类的static属性
++++ 使用java.lang.reflect进行反射调用
++++ 初始化类时，没有初始化父类，先初始化父类
++++ 虚拟机启动时，用户指定的主类（main）
***: 虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、
转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型;
****:类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，
并且向Java程序员提供了访问方法区内的数据结构的接口。;
@endmindmap
@startmindmap
+ JVM
++ 对象
+++ 对象的创建
++++ 根据new的参数是否能在常量池中定位到一个类的符号引用
+++++ 如果没有，说明还未定义该类，抛出ClassNotFoundException;
++++ 检查符号引用对应的类是否加载过
+++++ 如果没有，则进行类加载
++++ 根据方法区的信息确定为该类分配的内存空间大小
++++ 分配内存给对象
+++++ 栈上分配
++++++ 前提
+++++++ 开启逃逸分析(+XX:+DoEscapeAnalysis)
++++++++ 逃逸分析的作用就是分析 对象的作用域是否会逃逸出方法之外，\l在server虚拟机模式下才可以开启 （jdk1.6默认开启）
+++++++++ 方法逃逸:
++++++++++ 例如作为调用参数传递到其他方法中
+++++++++ 线程逃逸
++++++++++ 线程逃逸有可能被外部线程访问到，\l譬如赋值给类变量或可以在其他线程中访问的实例变量
+++++++ 开启标量替换 (+XX:+EliminateAllocations)
++++++++ 标量替换的作用是允许 将对象根据属性打散后分配再栈上，默认该配置为开启
+++++ 从堆中划分一块对应大小的内存空间给该对象
++++++ 指针碰撞
+++++++ java堆内存空间规整（连续）的情况下使用\l（java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定）
+++++++ 并发处理
++++++++ 1. 对内存分配的动作进行同步处理（CAS）
++++++++ 2. 本地线程分配缓冲 Thread Local Allocation Buffer (TLAB）
+++++++++ TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是线程专属的。
+++++++++ 在虚拟机的TLAB功能启动的情况下，在线程初始化时，\l虚拟机会为每个线程分配一块TLAB空间，\l只给当前线程使用，这样每个线程都单独拥有一个空间。
+++++++++ 如果需要分配内存，就在自己的空间上分配，\l这样就不存在竞争的情况，可以大大提升分配效率。
++++++ 空闲列表
+++++++ java堆空间不规整的情况下使用
++++ 对象中的成员变量赋上初始值
++++ 设置对象头信息
++++ 调用对象的构造函数进行初始化
+++ 对象的内存布局
++++ 对象头
+++++ Mark Word
++++++ 对象的hashCode
++++++ GC年龄
++++++ 锁信息（偏向锁，轻量级锁，重量级锁）
++++++ GC标志
+++++ Class metadata Address
++++++ 指向对象实例指针
++++ 对象的实例数据
++++ 对齐填充
+++ 对象的访问方式
++++ 指针
+++++ reference中存储的直接就是对象地址
++++ 句柄
+++++ java堆中将会划分出一块内存来作为句柄池，\lreference中存储的是对象的句柄地址，\l而句柄中包含了对象数据与类型各自的具体地址信息
++++ 两种方式的比较
+++++ 使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，\l在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
+++++ 使用直接指针访问方式的最大好处就是速度更快，\l它节省了一次指针定位的时间开销。HotSpot虚拟机使用的是直接指针访问的方式。
@endmindmap